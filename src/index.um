@inline definitions.um

@quantum-styles
@quantum-titlebar

@div .qm-banner
  @img: @attr src: quantum.svg
  @section: @div .qm-banner-text: A static site generator for nodejs

@qm.content

  @section
    @h1: About

    @p: Quantum is comprised of a simple markup language, and several modules for transforming the parsed markup into rendered web pages.

    @p: The process of converting markup into rendered html happens in a customisable pipeline of transforms. The transforms convert the markup from one form to another, eventually ending up as html which can be written to a file.

  @div #qm-block-1.qm-accent-block
    @section
      @graph
        @node read
          @name Read (index.um)
          @width 180
          @height 40
          @link one

        @node one
          @name Transform 1
          @width 200
          @height 40
          @link two

        @node two
          @name Transform 2
          @width 160
          @height 40
          @link ellipsis

        @node ellipsis
          @name ...
          @width 160
          @height 40
          @link n

        @node n
          @name Transform N
          @width 160
          @height 40
          @link result-file

        @node result-file
          @name Write (index.html)
          @width 160
          @height 40


  @div #qm-block-2.qm-tagline
    @section: A vague representation of how quantum works.

  @section

    @p: The most obvious use case is for declaring content to be rendered out to html, and quantum has plenty of support for doing just that. Whilst this is Quantum's most common use case, it is by no means limited to this domain. It could equally be used to convert markup into a variety of output formats (images, markdown, pdf, text, json, etc). Quantum makes this easy by providing a stepping stone from readable markup to a json struture that can be traversed in code.

    @p: Quantum can be used to decouple page content from the final page structure, allowing radical changes to be made to the way content is displayed without touching the content files.

    @p: Having the ability to manipulate the ast also opens up the possibility to add features that are not baked into the language, such as support for templating with basic logic, in-document type definitions, and even using diffs to describe what has changed between two versions of a document.

    @p: The code to set up the transforms follows a similar pattern to the above flowchart, making use of promises to provide a clean api for chaining transforms.

    @h1 #getting-started: Getting Started

    @h2: Install from npm

    @codeblock bash
      npm install --save-dev quantum-js
      npm install --save-dev quantum-html

    @h2: Basic html rendering example

  @div .qm-accent-block
    @section
      @graph
        @node read
          @name Read (index.um)
          @width 160
          @height 40
          @link transform-to-dom

        @node transform-to-dom
          @name Transform to virtual dom
          @width 220
          @height 40
          @link render-to-html

        @node render-to-html
          @name Transform to html
          @width 200
          @height 40
          @link output-to-file

        @node output-to-file
          @name Write (index.html)
          @width 200
          @height 40

  @div .qm-tagline
    @section: A typical setup for rendering to html.

  @section

    @p: This setup might seem overly complicated to start with, but having a customizable pipeline opens up opportunities to manipulate the parsed markup before rendering it out to html. This means that your content can, if you want, be completely detached from the page layout. The pipeline also provides a natural place to inject variables as the page is being rendered.

    @h3: Build code
    @codeblock js
      var quantum = require('quantum-core')
      var html = require('quantum-html')

      quantum.load('source.um')             // load and parse a source file
        .map(html())                        // transform the ast to virtual dom
        .map(html.stringify())              // render the virtual dom to html
        .map(quantum.write('target'))       // write the result to a file called output.html

    @p: The api takes inspiration from gulp's streaming api, applying the same concept to promises.

    @i: Wait, how does that actually work?
    @qm.infobox
      The function @code(js)[quantum.load('source.um')] returns a promise which contains a list of objects that hold the parsed results. In this case, we are just loading a single file, so that array will just contain one object, but we can still map over that array to apply the transforms. Since the promise returned from @code(js)[quantum.load()] is a bluebird promise, and bluebird promises have a utility @code(js)[.map] method defined on them, we can use that to achieve the clean api seen above.

    @qm.infobox
      Note: The map function will have to be changed to support handing automatically flattening lists of lists (for modules such as the version transform that can output multiple results for each input). When that is done, the above comment will need updating (since we will no longer be relying on exposing bluebird promises)


    @h3: source.um
    @codeblock um
      @inline source.um [text]

    @h3: output.html

    @codeblock html
      TODO: Add this


    @h1: The Markup @attr(id)[markup]

    @p: The markup language is simple, and should be easy to pick up. Everything is either an entity or is text. Entities are things that start with an @(@). An entity can have parameters and nested content.

    @codeblock um
      @inline the-markup.um [text]

    Parsing the above gives:

    @codeblock json
      @inline the-markup.json [text]

    @module-list
      @module quantum-html-hexagon: Adds renderers for hexagon components.
      @module quantum-html-api: General purpose renderers for creating api docs.

    @h1: Grunt/Gulp @attr(id)[gulp-grunt]

    @h2: Gulp

    @p: There is no need for a gulp plugin. The api can be used within a gulp task:

    @codeblock js
      var gulp = require('gulp')
      var quantum = require('quantum-core')
      var html = require('quantum-html')

      gulp.task('build', function(){
        return quantum.load('source.um')
          .map(html())
          .map(html.stringify())
          .map(quantum.write('target'))
      })

    @h2: Grunt

    @p: There is no grunt plugin yet. Want to make one?

    @h1: Api Docs @attr(id)[api]

    @qm.infobox
      Note: These should be moved to a separate page (or pages)

    @inline api/api.um






@footer
  @section
    @p: Created @(@) Ocado Technology