@api quantum-dom
  @inline api/*.um




// -------- Prototypes --------

function PageModifier (options) {
  this.options = options
}

// -------- Factories --------


// creates an element of the type given
function bodyClassed (cls, classed) {
  return new PageModifier({
    type: 'body-classed',
    class: cls,
    classed: classed
  })
}

// renders the elements given to html
function stringify (elements, options) {
  const embedAssets = options ? options.embedAssets !== false : true
  const assetPath = options ? options.assetPath || '' : ''

  const [headElementWrappers, modifiers, assets] = extractTypes(elements, [HeadInjectWrapper, PageModifier, Asset])

  const latestById = {}
  headElementWrappers.forEach(w => {
    if (w.options.id) {
      latestById[w.options.id] = w
    }
  })

  const bodyClassesMap = {}
  modifiers
    .filter(m => m.options.type === 'body-classed')
    .forEach(m => {
      bodyClassesMap[m.options.class] = m.options.classed
    })

  const bodyClass = Object.keys(bodyClassesMap)
    .filter(c => bodyClassesMap[c])
    .join(' ')

  const headElements = headElementWrappers
    .filter(w => w.options.id ? w === latestById[w.options.id] : true)
    .map(w => w.element)
    .map(e => e.stringify ? e.stringify() : (isString(e) ? e : ''))
    .join('')

  const bodyElements = elements
    .map(e => e !== undefined && e.stringify ? e.stringify() : (isString(e) ? e : ''))
    .join('')

  // XXX: add an option for choosing where the assets live

  // only keep unique assets
  const uniqueAssetsMap = {}
  assets.forEach(asset => {
    uniqueAssetsMap[asset.url] = asset
  })
  const uniqueAssets = Object.keys(uniqueAssetsMap).map(k => uniqueAssetsMap[k])

  const exportAssets = []

  const stylesheets = Promise.all(uniqueAssets.filter(a => a.url.endsWith('.css')).map(s => {
    if (embedAssets) {
      // XXX: make this loader configurable so that assets can be cached
      return fs.readFileAsync(s.filename, 'utf-8').then(content => `<style>${content}</style>`)
    } else {
      exportAssets.push(s)
      return `<link rel="stylesheet" href="${assetPath}${s.url}"></link>`
    }
  }))

  const scripts = Promise.all(uniqueAssets.filter(a => a.url.endsWith('.js')).map(s => {
    if (embedAssets) {
      // XXX: make this loader configurable so that assets can be cached
      return fs.readFileAsync(s.filename, 'utf-8').then(content => `<script>${content}</script>`)
    } else {
      exportAssets.push(s)
      return `<script src="${assetPath}${s.url}"></script>`
    }
  }))

  // Also export any un-embeddable assets
  uniqueAssets.forEach(asset => {
    if (!asset.url.endsWith('.js') && !asset.url.endsWith('.css')) {
      exportAssets.push(asset)
    }
  })

  return Promise.all([stylesheets, scripts])
    .spread((stylesheets, scripts) => {
      const head = `<head>${stylesheets.join('')}${headElements}</head>`
      const bodyClasses = `qm-body-font${bodyClass ? ` ${bodyClass}` : ''}`
      const openBodyTag = `<body class="${bodyClasses}">`
      const body = `${openBodyTag}${bodyElements}${scripts.join('')}</body>`
      const html = `<!DOCTYPE html>\n<html>\n${head}\n${body}</html>`
      return {
        html: html,
        assets: exportAssets
      }
    })
}

module.exports = {
  bodyClassed,
  PageModifier,
  stringify
}
