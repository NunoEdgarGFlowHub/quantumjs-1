@prototype Selection
  @added 2.0.0

  @description
    An object that wraps an entity. This object has useful methods for extracting
    information from, and updating entities.

    @@codeblock js
      const quantum = require('quantum-js')

  @method entity
    @description
      Returns the underlying entity this @type[Selection] wraps
    @returns Object
      @description
        The entity this selection wraps

  @method type
    @description
      Gets the @code[type] property from the underlying entity

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        console.log(selection.type()) // Prints "blogEntry"

    @returns String
      @description
        Returns the underlying entity's @code[type] property

  @method type
    @description
      Sets the @code[type] property for the underlying entity

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        console.log(selection.type()) // Prints "blogEntry"
        console.log(entity.type)      // Prints "blogEntry"

        // Change the entity type
        selection.type('myBlogEntry')

        console.log(selection.type()) // Prints "myBlogEntry"
        console.log(entity.type)      // Prints "myBlogEntry"

    @param type [String]: The new type
    @returns Selection
      @description
        This @type[Selection] for further chaining


  @method param
    @description
      Gets the nth entity parameter.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.param(0) // '10/12/17'
        selection.param(1) // undefined

    @param index [Number]
      @description: The index of the parameter to get
    @returns String
      @description
        The parameter that was as position index. Will be
        @code[undefined] if an out of bounds parameter is accessed.

  @method param
    @description
      Sets the nth entity parameter.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        // get the current parameter value
        selection.param(0) // '10/12/17'

        // set the parameter and observe the change
        selection.param(0, "11/12/17")
        selection.param(0) // "11/12/17"

    @param index [Number]
      @description: The index of the parameter to get
    @param param [String]
      @description: The parameter value to set
    @returns Selection
      @description
        This @type[Selection] instance

  @method params
    @description
      Gets the parameters as an array.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.params() // ['param1', 'param2']

    @returns [Array[String]]
      @description
        The parameters of the selected entity

  @method params
    @description
      Sets the parameters as an array.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.params() // ['param1', 'param2']

        selection.params(['p1', 'p2'])
        selection.params() // ['p1', 'p2']

    @returns Selection
      @description
        This @type[Selection] instance

  @method addParam
    @description
      Adds a new parameter to the end of the parameters list

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.params() // ['param1', 'param2']

        selection.addParam(['param3'])
        selection.params() // ['param1', 'param2', 'param3']

    @param param [String]
      The parameter value to add

    @returns Selection
      @description
        This @type[Selection] instance

  @method content
    @description
      Gets the content of this entity as an array

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)
        selection.content() // ['Blah blah blah']

    @returns Selection
      @description
        This @type[Selection] instance

  @method content
    @description
      Sets the content of this entity as an array

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)
        selection.content() // ['Blah blah blah']

        selection.content(['New Content', 'Second line'])
        selection.content() // ['New Content', 'Second line']

    @param content [Array[String/Object]]
      @description
        The content to give the selected entity

    @returns Selection
      @description
        This @type[Selection] instance

  @method add
    @description
      Adds a new entry to the entities content array

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)
        selection.content() // ['Blah blah blah']

        selection.add('Second line')
        selection.content() // ['Blah blah blah', 'Second line']

        // Entities can also be added
        selection.add({
          type: 'tagline',
          params: [],
          content: []
        })

    @param content [String/Object]
      @description
        The content to add to the end of the content array. Can either be a
        string, or an entity object.

    @returns Selection
      @description
        This @type[Selection] instance

  @method addAfter
    @description
      If this selection has a parent, this method can be used to add content
      after this one in the parent's content.

      @codeblock js

        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            {
              type: "child",
              params: [],
              content: []
            },
            "End content"
          ]
        }

        const selection = quantum.select(entity)
        selection.content()
        /*
          [
            {
              type: "child",
              params: [],
              content: []
            },
            "End content"
          ]
        */

        const child = selection.select('child')
        child.addAfter('New line')

        selection.content()
        /*
          [
            {
              type: "child",
              params: [],
              content: []
            },
            "New line",
            "End content"
          ]
        */

    @param content [String/Object]
      @description
        The content to add to the end of the content array. Can either be a
        string, or an entity object.

    @returns Selection
      @description
        This @type[Selection] instance

  @method ps (ps)
    if (arguments.length > 0) {
      checkNotFiltered(this)
      this._entity.params = ps.split(' ')
      return this
    } else {
      return this._entity.params.join(' ')
    }

  @method cs (cs)
    if (arguments.length > 0) {
      checkNotFiltered(this)
      this._entity.content = cs.split('\n')
      return this
    } else {
      return this._entity.content.filter(isText).join('\n')
    }

  @method has (type, options)
    if (options && options.recursive) {
      const parent = this
      return this._entity.content.some((child) => child.type === type) ||
        this._entity.content.some((child) => {
          return isEntity(child) && select(child, parent).has(type, options)
        })
    } else {
      return this._entity.content.some((child) => child.type === type)
    }

  @method hasParams ()
    return this._entity.params.length > 0

  @method hasContent ()
    return this._entity.content.length > 0

  @method isEmpty ()
    return !this._entity.content.some((d) => {
      return isEntity(d) || d.trim() !== ''
    })

  @method parent ()
    return this._parent

  @method select (type, options)
    return this.selectAll(type, options)[0] || emptySelection()

  @method selectAll (type, options)
    const parent = this
    const res = []
    if (Array.isArray(type)) {
      const types = type
      const a = this._entity.content
      const l = a.length
      for (let i = 0; i < l; i++) {
        const child = a[i]
        if (types.indexOf(child.type) > -1) {
          res.push(select(child, parent))
        }
      }
    } else {
      const a = this._entity.content
      const l = a.length
      for (let i = 0; i < l; i++) {
        const child = a[i]
        if (child.type === type) {
          res.push(select(child, parent))
        }
      }
    }

    if (options && options.recursive) {
      const a = this._entity.content
      const l = a.length
      for (let i = 0; i < l; i++) {
        const child = a[i]
        if (isEntity(child)) {
          // OPTIM: do this without the recursion
          select(child, parent).selectAll(type, options).forEach(d => res.push(d))
        }
      }
    }

    if (options && options.required && res.length === 0) {
      throw new Error('the field ' + type + ' is options (and missing)')
    }

    return res

  @method selectUpwards (type)
    let s = this
    while (s.parent()) {
      s = s.parent()
      if (s.type() === type) {
        return s
      }
    }

  @method filter (f)
    if (Array.isArray(f)) {
      return this.filter((entity) => f.indexOf(entity.type) > -1)
    } else if (isText(f)) {
      return this.filter((entity) => entity.type === f)
    } else {
      const filteredEntity = {
        type: this._entity.type,
        params: this._entity.params,
        content: this._entity.content.filter(f)
      }
      return new Selection(filteredEntity, this._parent, true, this._renderContext)
    }

  @method remove ()
    if (this._parent) {
      if (this._parent.removeChild(this._entity)) {
        this._parent = undefined
      }
    } else {
      throw new Error("An entity with no parent can't be removed")
    }

  @method removeChild (childEntity)
    const childIndex = this._entity.content.indexOf(childEntity)
    if (childIndex > -1) {
      this._entity.content.splice(childIndex, 1)
      return true
    } else {
      return false
    }

  @method removeChildOfType (type, options)
    if (Array.isArray(type)) {
      const self = this
      // OPTIM: remove the use of map
      return type.map((t) => self.removeChildOfType(t, options))
    } else {
      let i = 0
      const content = this._entity.content
      while (i < content.length) {
        const entity = content[i]
        if (isEntity(entity) && entity.type === type) {
          content.splice(i, 1)
          return entity
        }
        i++
      }

      if (options && options.recursive) {
        i = 0
        while (i < content.length) {
          const child = content[i]
          if (isEntity(child)) {
            const removed = select(child).removeChildOfType(type, options)
            if (removed) {
              return removed
            }
          }
          i++
        }
      }
    }

  @method removeAllChildOfType (type, options)
    if (Array.isArray(type)) {
      const self = this
      // OPTIM: remove the use of map
      return type.map((t) => self.removeAllChildOfType(t, options))
    } else {
      const result = []
      let i = 0
      const content = this._entity.content
      while (i < content.length) {
        const entity = content[i]
        if (isEntity(entity) && entity.type === type) {
          content.splice(i, 1)
          result.push(entity)
        } else {
          i++
        }
      }

      if (options && options.recursive) {
        i = 0
        while (i < content.length) {
          const child = content[i]
          if (isEntity(child)) {
            select(child).removeAllChildOfType(type, options).forEach((removed) => {
              result.push(removed)
            })
          }
          i++
        }
      }

      return result
    }

  @method transformContext (obj)
    if (arguments.length > 0) {
      this._renderContext = obj
      return this
    } else {
      return this._renderContext
    }

  @method transform (transformer)
    return maybePromiseAll(this._entity.content.map((child) => {
      return transformer(isEntity(child) ? select(child, this) : child)
    }))
