@prototype Selection
  @added 2.0.0

  @description
    An object that wraps an entity. This object has useful methods for extracting
    information from, and updating entities.

    @@codeblock js
      const quantum = require('quantum-js')

  @method entity
    @description
      Returns the underlying entity this @type[Selection] wraps
    @returns Object
      @description
        The entity this selection wraps

  @method type
    @description
      Gets the @code[type] property from the underlying entity

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        console.log(selection.type()) // Prints "blogEntry"

    @returns String
      @description
        Returns the underlying entity's @code[type] property

  @method type
    @description
      Sets the @code[type] property for the underlying entity

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        console.log(selection.type()) // Prints "blogEntry"
        console.log(entity.type)      // Prints "blogEntry"

        // Change the entity type
        selection.type('myBlogEntry')

        console.log(selection.type()) // Prints "myBlogEntry"
        console.log(entity.type)      // Prints "myBlogEntry"

    @param type [String]: The new type
    @returns Selection
      @description
        This @type[Selection] for further chaining


  @method param (i, param)
    if (arguments.length > 1) {
      checkNotFiltered(this)
      this._entity.params[i] = param
      return this
    } else {
      return this._entity.params[i]
    }

  @method params (params)
    if (arguments.length > 0) {
      checkNotFiltered(this)
      this._entity.params = params
      return this
    } else {
      return this._entity.params
    }

  @method addParam (param)
    checkNotFiltered(this)
    this._entity.params.push(param)
    return this

  @method content (content)
    if (arguments.length > 0) {
      checkNotFiltered(this)
      this._entity.content = content
      return this
    } else {
      return this._entity.content
    }

  @method add (content)
    checkNotFiltered(this)
    this._entity.content.push(content)
    return this

  @method addAfter (content)
    if (this._parent) {
      const parentContent = this._parent.content()
      const index = parentContent.indexOf(this._entity)
      if (index > -1) {
        if (Array.isArray(content)) {
          parentContent.splice.apply(parentContent, [index + 1, 0].concat(content))
        } else {
          parentContent.splice(index + 1, 0, content)
        }
      }
      return this
    } else {
      throw new Error("Can't add content after this element - it has no parent")
    }

  @method append (content)
    checkNotFiltered(this)
    this._entity.content.push(content)
    return select(content, this)

  @method ps (ps)
    if (arguments.length > 0) {
      checkNotFiltered(this)
      this._entity.params = ps.split(' ')
      return this
    } else {
      return this._entity.params.join(' ')
    }

  @method cs (cs)
    if (arguments.length > 0) {
      checkNotFiltered(this)
      this._entity.content = cs.split('\n')
      return this
    } else {
      return this._entity.content.filter(isText).join('\n')
    }

  @method has (type, options)
    if (options && options.recursive) {
      const parent = this
      return this._entity.content.some((child) => child.type === type) ||
        this._entity.content.some((child) => {
          return isEntity(child) && select(child, parent).has(type, options)
        })
    } else {
      return this._entity.content.some((child) => child.type === type)
    }

  @method hasParams ()
    return this._entity.params.length > 0

  @method hasContent ()
    return this._entity.content.length > 0

  @method isEmpty ()
    return !this._entity.content.some((d) => {
      return isEntity(d) || d.trim() !== ''
    })

  @method parent ()
    return this._parent

  @method select (type, options)
    return this.selectAll(type, options)[0] || emptySelection()

  @method selectAll (type, options)
    const parent = this
    const res = []
    if (Array.isArray(type)) {
      const types = type
      const a = this._entity.content
      const l = a.length
      for (let i = 0; i < l; i++) {
        const child = a[i]
        if (types.indexOf(child.type) > -1) {
          res.push(select(child, parent))
        }
      }
    } else {
      const a = this._entity.content
      const l = a.length
      for (let i = 0; i < l; i++) {
        const child = a[i]
        if (child.type === type) {
          res.push(select(child, parent))
        }
      }
    }

    if (options && options.recursive) {
      const a = this._entity.content
      const l = a.length
      for (let i = 0; i < l; i++) {
        const child = a[i]
        if (isEntity(child)) {
          // OPTIM: do this without the recursion
          select(child, parent).selectAll(type, options).forEach(d => res.push(d))
        }
      }
    }

    if (options && options.required && res.length === 0) {
      throw new Error('the field ' + type + ' is options (and missing)')
    }

    return res

  @method selectUpwards (type)
    let s = this
    while (s.parent()) {
      s = s.parent()
      if (s.type() === type) {
        return s
      }
    }

  @method filter (f)
    if (Array.isArray(f)) {
      return this.filter((entity) => f.indexOf(entity.type) > -1)
    } else if (isText(f)) {
      return this.filter((entity) => entity.type === f)
    } else {
      const filteredEntity = {
        type: this._entity.type,
        params: this._entity.params,
        content: this._entity.content.filter(f)
      }
      return new Selection(filteredEntity, this._parent, true, this._renderContext)
    }

  @method remove ()
    if (this._parent) {
      if (this._parent.removeChild(this._entity)) {
        this._parent = undefined
      }
    } else {
      throw new Error("An entity with no parent can't be removed")
    }

  @method removeChild (childEntity)
    const childIndex = this._entity.content.indexOf(childEntity)
    if (childIndex > -1) {
      this._entity.content.splice(childIndex, 1)
      return true
    } else {
      return false
    }

  @method removeChildOfType (type, options)
    if (Array.isArray(type)) {
      const self = this
      // OPTIM: remove the use of map
      return type.map((t) => self.removeChildOfType(t, options))
    } else {
      let i = 0
      const content = this._entity.content
      while (i < content.length) {
        const entity = content[i]
        if (isEntity(entity) && entity.type === type) {
          content.splice(i, 1)
          return entity
        }
        i++
      }

      if (options && options.recursive) {
        i = 0
        while (i < content.length) {
          const child = content[i]
          if (isEntity(child)) {
            const removed = select(child).removeChildOfType(type, options)
            if (removed) {
              return removed
            }
          }
          i++
        }
      }
    }

  @method removeAllChildOfType (type, options)
    if (Array.isArray(type)) {
      const self = this
      // OPTIM: remove the use of map
      return type.map((t) => self.removeAllChildOfType(t, options))
    } else {
      const result = []
      let i = 0
      const content = this._entity.content
      while (i < content.length) {
        const entity = content[i]
        if (isEntity(entity) && entity.type === type) {
          content.splice(i, 1)
          result.push(entity)
        } else {
          i++
        }
      }

      if (options && options.recursive) {
        i = 0
        while (i < content.length) {
          const child = content[i]
          if (isEntity(child)) {
            select(child).removeAllChildOfType(type, options).forEach((removed) => {
              result.push(removed)
            })
          }
          i++
        }
      }

      return result
    }

  @method transformContext (obj)
    if (arguments.length > 0) {
      this._renderContext = obj
      return this
    } else {
      return this._renderContext
    }

  @method transform (transformer)
    return maybePromiseAll(this._entity.content.map((child) => {
      return transformer(isEntity(child) ? select(child, this) : child)
    }))
