@prototype Selection
  @added 2.0.0

  @description
    An object that wraps an entity. This object has useful methods for extracting
    information from, and updating entities.

    @@codeblock js
      const quantum = require('quantum-js')

  @method entity
    @description
      Returns the underlying entity this @type[Selection] wraps
    @returns Object
      @description
        The entity this selection wraps

  @method type
    @description
      Gets the @code[type] property from the underlying entity

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        console.log(selection.type()) // Prints "blogEntry"

    @returns String
      @description
        Returns the underlying entity's @code[type] property

  @method type
    @description
      Sets the @code[type] property for the underlying entity

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        console.log(selection.type()) // Prints "blogEntry"
        console.log(entity.type)      // Prints "blogEntry"

        // Change the entity type
        selection.type('myBlogEntry')

        console.log(selection.type()) // Prints "myBlogEntry"
        console.log(entity.type)      // Prints "myBlogEntry"

    @param type [String]: The new type
    @returns Selection
      @description
        This @type[Selection] for further chaining


  @method param
    @description
      Gets the nth entity parameter.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.param(0) // '10/12/17'
        selection.param(1) // undefined

    @param index [Number]
      @description: The index of the parameter to get
    @returns String
      @description
        The parameter that was as position index. Will be
        @code[undefined] if an out of bounds parameter is accessed.

  @method param
    @description
      Sets the nth entity parameter.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'blogEntry',
          params: ['10/12/17'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        // get the current parameter value
        selection.param(0) // '10/12/17'

        // set the parameter and observe the change
        selection.param(0, "11/12/17")
        selection.param(0) // "11/12/17"

    @param index [Number]
      @description: The index of the parameter to get
    @param param [String]
      @description: The parameter value to set
    @returns Selection
      @description
        This @type[Selection] instance

  @method params
    @description
      Gets the parameters as an array.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.params() // ['param1', 'param2']

    @returns [Array[String]]
      @description
        The parameters of the selected entity

  @method params
    @description
      Sets the parameters as an array.

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.params() // ['param1', 'param2']

        selection.params(['p1', 'p2'])
        selection.params() // ['p1', 'p2']

    @returns Selection
      @description
        This @type[Selection] instance

  @method addParam
    @description
      Adds a new parameter to the end of the parameters list

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.params() // ['param1', 'param2']

        selection.addParam(['param3'])
        selection.params() // ['param1', 'param2', 'param3']

    @param param [String]
      The parameter value to add

    @returns Selection
      @description
        This @type[Selection] instance

  @method content
    @description
      Gets the content of this entity as an array

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)
        selection.content() // ['Blah blah blah']

    @returns Selection
      @description
        This @type[Selection] instance

  @method content
    @description
      Sets the content of this entity as an array

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)
        selection.content() // ['Blah blah blah']

        selection.content(['New Content', 'Second line'])
        selection.content() // ['New Content', 'Second line']

    @param content [Array[String/Object]]
      @description
        The content to give the selected entity

    @returns Selection
      @description
        This @type[Selection] instance

  @method add
    @description
      Adds a new entry to the entities content array

      @codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)
        selection.content() // ['Blah blah blah']

        selection.add('Second line')
        selection.content() // ['Blah blah blah', 'Second line']

        // Entities can also be added
        selection.add({
          type: 'tagline',
          params: [],
          content: []
        })

    @param content [String/Object]
      @description
        The content to add to the end of the content array. Can either be a
        string, or an entity object.

    @returns Selection
      @description
        This @type[Selection] instance

  @method addAfter
    @description
      If this selection has a parent, this method can be used to add content
      after this one in the parent's content.

      @codeblock js

        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            {
              type: "child",
              params: [],
              content: []
            },
            "End content"
          ]
        }

        const selection = quantum.select(entity)
        selection.content()
        /*
          [
            {
              type: "child",
              params: [],
              content: []
            },
            "End content"
          ]
        */

        const child = selection.select('child')
        child.addAfter('New line')

        selection.content()
        /*
          [
            {
              type: "child",
              params: [],
              content: []
            },
            "New line",
            "End content"
          ]
        */

    @param content [String/Object]
      @description
        The content to add to the end of the content array. Can either be a
        string, or an entity object.

    @returns Selection
      @description
        This @type[Selection] instance

  @method ps
    @description
      Gets the parameters as a string

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.ps() // param1 param2

    @returns String
      @description
        The parameters joined with spaces into a single string

  @method ps
    @description
      Sets the parameters as a string

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Blah blah blah'
          ]
        }

        const selection = quantum.select(entity)

        selection.ps() // param1 param2

        selection.ps('p1 p2')
        selection.params() // ['p1', 'p2']

    @param ps [String]
      @description
        A string that should be split on spaces, the result of which will become
        the params array for the entity.

    @returns String
      @description
        The parameters joined with spaces into a single string

  @method cs
    @description
      Gets the parameters as a string

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Line 1',
            'Line 2'
          ]
        }

        const selection = quantum.select(entity)

        selection.cs() // 'Line1\nLine2'

    @returns String
      @description
        The content array joined with newline characters into a single string.
        Any entity objects will be ignored.

  @method cs
    @description
      Sets the parameters as a string

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            'Line 1',
            'Line 2'
          ]
        }

        const selection = quantum.select(entity)

        selection.cs() // 'Line1\nLine2'

        selection.cs('Line1\nLine2\nLine3')
        selection.content() // ['Line 1', 'Line 2', 'Line 3']

    @param cs [String]
      @description
        A string that should be split on new lines, the result of which will become
        the content array for the entity.

    @returns String
      @description
        The content joined with new line characters into a single string

  @method has
    @description
      Checks if an entity has a child entity of a particular type

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'example',
          params: ['param1', 'param2'],
          content: [
            {
              type: 'child1',
              params: [],
              content: []
            },
            {
              type: 'child2',
              params: [],
              content: [
                type: 'child3',
                params: [],
                content: [

                ]
              ]
            }
          ]
        }

        const selection = quantum.select(entity)

        selection.has('child1') // true
        selection.has('child2') // true
        selection.has('child3') // false
        selection.has('child3', {recursive: true}) // true
        selection.has('child4', {recursive: true}) // false

    @param type [String]
      @description
        The entity type to look for
    @param? options [Object]
      @property recursive [Boolean]
        @description
          True to do a recursive search down the tree for the type
        @default: false
    @returns Boolean
      @description
        Returns true if the selected entity has a child entity of type @code[type]

  @method hasParams
    @description
      Returns true if the selected entity has any parameters

      @codeblock js
        const quantum = require('quantum-js')

        const entity1 = {
          type: 'example',
          params: [],
          content: []
        }

        const entity2 = {
          type: 'example',
          params: ['param1', 'param2'],
          content: []
        }

        const selection1 = quantum.select(entity1)
        selection1.hasParams() // false

        const selection2 = quantum.select(entity2)
        selection2.hasParams() // true

    @returns Boolean
      @description
        Returns true if the entity has 1 or more parameters, false otherwise

  @method hasContent
    @description
      Returns true if the selected entity has any content

      @@codeblock js
        const quantum = require('quantum-js')

        const entity1 = {
          type: 'example',
          params: [],
          content: []
        }

        const entity2 = {
          type: 'example',
          params: [],
          content: [
            'Line 1',
            {
              type: 'child',
              params: [],
              content: []
            }
          ]
        }

        const selection1 = quantum.select(entity1)
        selection1.hasContent() // false

        const selection2 = quantum.select(entity2)
        selection2.hasContent() // true

    @returns Boolean
      @description
        Returns true if the entity has content, false otherwise

  @method isEmpty
    @description
      Returns true if the selected component has either no content or all the
      content line are empty strings.

      @@codeblock js
        const quantum = require('quantum-js')

        const entity1 = {
          type: 'example',
          params: [],
          content: []
        }

        const entity2 = {
          type: 'example',
          params: [],
          content: [
            "",
            ""
          ]
        }

        const entity3 = {
          type: 'example',
          params: [],
          content: [
            'Line 1',
            {
              type: 'child',
              params: [],
              content: []
            }
          ]
        }

        const selection1 = quantum.select(entity1)
        selection1.isEmpty() // true

        const selection2 = quantum.select(entity2)
        selection2.isEmpty() // true

        const selection3 = quantum.select(entity3)
        selection3.isEmpty() // true

    @returns Boolean
      @description
        Returns true if there is no content, the content is made up of empty
        strings.

  @method parent
    @description
      Gets the parent entity wrapped in a selection. This only works if
      @code[Selection::select] has been used to select 'down' the tree:

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'parent',
          params: [],
          content: [
            {
              type: 'childExample',
              params: [],
              content: [

              ]
            }
          ]
        }

        const parentSelection = quantum.select(entity)
        const childSelection = quantum.select('childExample')

        parentSelection.parent() // undefined
        childSelection.parent() // == parentSelection

    @returns Selection
      Returns the parent @type[Selection] if it exists, otherwise @code[undefined]


  @method select
    @description
      Selects a child entity from the selected entity.

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'parent',
          params: [],
          content: [
            {
              type: 'childExample',
              params: [],
              content: [

              ]
            }
          ]
        }

        const selection = quantum.select(entity)
        selection.select('childExample') // returns a new selection wrapping the 'childExample' entity

    @param type [String]
      @description
        The type of entity to select
    @param options [Object]
      @property recursive [Boolean]
        @description
          Set to true to search recursively down the child entities to search
          for this type. It will do a depth first search.
        @default: false
      @property required [Boolean]
        @description
          Set to true to throw an error when this type is not found
        @default: false

    @returns Selection
      @description
        Returns a new selection that wraps the first entity of type @code[type]
        that was found. If there was no entity of type @code[type] found, a
        @type[Selection] will still be returned, but will contain an empty entity
        that looks like this

        @@codeblock js
          {
            type: '',
            params: [],
            content: []
          }

  @method selectAll
    @description
      Selects all children of a particular type.

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'recipe',
          params: ['Omelette'],
          content: [
            {
              type: 'ingredient',
              params: ['Eggs'],
              content: []
            },
            {
              type: 'ingredient',
              params: ['Milk'],
              content: []
            },
            {
              type: 'ingredient',
              params: ['Salt'],
              content: []
            },
            {
              type: 'ingredient',
              params: ['Pepper'],
              content: []
            }
          ]
        }

        const selection = quantum.select(entity)
        const ingredients = selection.selectAll('ingredient') // returns an array of 4 Selections

      By default it @code[selectAll] will only search through the direct childen.
      To search recursively down the tree, add the @code[{recursive: true}] option.

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'parent',
          params: [],
          content: [
            {
              type: 'child',
              params: [],
              content: [
                {
                  type: 'child',
                  params: [],
                  content: []
                }
              ]
            },
            {
              type: 'child',
              params: [],
              content: [
                {
                  type: 'child',
                  params: [],
                  content: []
                },
                {
                  type: 'child',
                  params: [],
                  content: []
                }
              ]
            },
          ]
        }

        const selection = quantum.select(entity)
        selection.selectAll('child', { recursive: true }) // returns an array of 5 Selections

    @param type [String]
      @description
        The type of entity to select
    @param options [Object]
      @property recursive [Boolean]
        @description
          Set to true to search recursively down the child entities to search
          for this type. It will do a depth first search.
        @default: false
      @property required [Boolean]
        @description
          Set to true to throw an error when this type is not found
        @default: false

    @returns [Array[Selection]]
      @description
        Returns the entities that were found, each wraped in a @type[Selection].
        If no results are found an empty array will be returned.

  @method selectAll
    @description
      Selects all children of a particular type.

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'recipe',
          params: ['Omelette'],
          content: [
            {
              type: 'ingredient',
              params: ['Eggs'],
              content: []
            },
            {
              type: 'ingredient',
              params: ['Milk'],
              content: []
            },
            {
              type: 'ingredient',
              params: ['Salt'],
              content: []
            },
            {
              type: 'ingredient',
              params: ['Pepper'],
              content: []
            },
            {
              type: 'step',
              params: [],
              content: ['Beat eggs and milk to gether in a bowl and add salt and pepper']
            },
            {
              type: 'step',
              params: [],
              content: ['Melt some butter in a frying pan']
            },
            {
              type: 'step',
              params: [],
              content: ['Pour egg mixture into the frying pan and cook.']
            }
          ]
        }

        const selection = quantum.select(entity)
        const ingredients = selection.selectAll('ingredient') // returns an array of 4 Selections
        const steps = selection.selectAll('step') // returns an array of 3 Selections
        const ingredientsAndSteps = selection.selectAll(['ingredient', 'step']) // returns an array of 7 Selections

      By default it @code[selectAll] will only search through the direct childen.
      To search recursively down the tree, add the @code[{recursive: true}] option.

      @@codeblock js
        const quantum = require('quantum-js')

        const entity = {
          type: 'parent',
          params: [],
          content: [
            {
              type: 'child1',
              params: [],
              content: [
                {
                  type: 'child2',
                  params: [],
                  content: []
                }
              ]
            },
            {
              type: 'child2',
              params: [],
              content: [
                {
                  type: 'child1',
                  params: [],
                  content: []
                },
                {
                  type: 'child2',
                  params: [],
                  content: []
                }
              ]
            },
          ]
        }

        const selection = quantum.select(entity)
        selection.selectAll(['child1', 'child2'], { recursive: true }) // returns an array of 5 Selections

    @param types [Array[String]]
      @description
        The types of entities to select
    @param options [Object]
      @property recursive [Boolean]
        @description
          Set to true to search recursively down the child entities to search
          for this type. It will do a depth first search.
        @default: false
      @property required [Boolean]
        @description
          Set to true to throw an error when no results are found
        @default: false

    @returns [Array[Selection]]
      @description
        Returns the entities that were found, each wraped in a @type[Selection].
        If no results are found an empty array will be returned.

  @method selectUpwards (type)
    let s = this
    while (s.parent()) {
      s = s.parent()
      if (s.type() === type) {
        return s
      }
    }

  @method filter (f)
    if (Array.isArray(f)) {
      return this.filter((entity) => f.indexOf(entity.type) > -1)
    } else if (isText(f)) {
      return this.filter((entity) => entity.type === f)
    } else {
      const filteredEntity = {
        type: this._entity.type,
        params: this._entity.params,
        content: this._entity.content.filter(f)
      }
      return new Selection(filteredEntity, this._parent, true, this._renderContext)
    }

  @method remove ()
    if (this._parent) {
      if (this._parent.removeChild(this._entity)) {
        this._parent = undefined
      }
    } else {
      throw new Error("An entity with no parent can't be removed")
    }

  @method removeChild (childEntity)
    const childIndex = this._entity.content.indexOf(childEntity)
    if (childIndex > -1) {
      this._entity.content.splice(childIndex, 1)
      return true
    } else {
      return false
    }

  @method removeChildOfType (type, options)
    if (Array.isArray(type)) {
      const self = this
      // OPTIM: remove the use of map
      return type.map((t) => self.removeChildOfType(t, options))
    } else {
      let i = 0
      const content = this._entity.content
      while (i < content.length) {
        const entity = content[i]
        if (isEntity(entity) && entity.type === type) {
          content.splice(i, 1)
          return entity
        }
        i++
      }

      if (options && options.recursive) {
        i = 0
        while (i < content.length) {
          const child = content[i]
          if (isEntity(child)) {
            const removed = select(child).removeChildOfType(type, options)
            if (removed) {
              return removed
            }
          }
          i++
        }
      }
    }

  @method removeAllChildOfType (type, options)
    if (Array.isArray(type)) {
      const self = this
      // OPTIM: remove the use of map
      return type.map((t) => self.removeAllChildOfType(t, options))
    } else {
      const result = []
      let i = 0
      const content = this._entity.content
      while (i < content.length) {
        const entity = content[i]
        if (isEntity(entity) && entity.type === type) {
          content.splice(i, 1)
          result.push(entity)
        } else {
          i++
        }
      }

      if (options && options.recursive) {
        i = 0
        while (i < content.length) {
          const child = content[i]
          if (isEntity(child)) {
            select(child).removeAllChildOfType(type, options).forEach((removed) => {
              result.push(removed)
            })
          }
          i++
        }
      }

      return result
    }

  @method transformContext (obj)
    if (arguments.length > 0) {
      this._renderContext = obj
      return this
    } else {
      return this._renderContext
    }

  @method transform (transformer)
    return maybePromiseAll(this._entity.content.map((child) => {
      return transformer(isEntity(child) ? select(child, this) : child)
    }))
