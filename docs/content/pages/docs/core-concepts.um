@inline ../../shared/shared.um

@titlebar

@topSection
  @breadcrumb
    @item /: Home
    @item /docs/: Docs
    @item /docs/core-concepts/: Core Concepts
  @title Core Concepts
  @description
    This page explains some of the concepts used in quantumjs, including the pipeline, pipeline transforms and entity html transforms.

@contentSection
  @siteSidebars
  @topic The Markup Language
    @sheet
      Content is written using the quantum markup language. Here is an overview of the language:

    @@codeblock um

      \# comments start with a hash

      \# basic structure of an entity
      @type parameters: Content

      \# Entities can contain multiple lines of text content:
      @person parameter1 parameter2
        Name: Alejandro
        Age: 32

      \# And can also have nested entites
      @person parameter1 parameter2
        @name: Alejandro
        @age: 32

      \# Content may be mixed between entities and text
      @button
        @icon fa fa-add
        Click Me!

      \# Entites can also use a more compact single line syntax (when written like this they are called inline entites):
      @type(parameters)[Content]

      \# Inline entites may be placed in the middle of text
      This line has an @bold[inline] entity

      \# The above button example could also be written like this
      @button: @icon(fa fa-add) Click Me!

      \# Parameters with spaces should be wrapped in [...]
      @person parameter1 [parameter2 with spaces]

      \# escaping the @ sign is done by wrapping it (and optionally surrounding text) in @(...)
      @(your.name@ocado.com)

      \# nested content may be completely escaped by starting an entity with @@
      @@codeblock um
        \# this content is treated as text. No entites are parsed when in @@ mode
        @person
          @name: Alejandro
          @age: 32

      \# The hash character can be escaped with \#




  @topic The Pipeline
    @sheet
      One standout feature the quantum has is the way in which it turns markup into
      html. It uses a chain of functions to first parse the markup, then apply
      various transforms to get the output in the right format before turning it into
      html. This might sound a bit abstract, and it might not be clear at first why this
      is useful, but it turns out that taking this approach allows multiple useful features
      to be added on top of the basic markup language (versioning, automatic table of contents
      generation, templating logic and more).

    @label
      A typical pipeline for turning quantum markup into html

    @sheet
      @diagram
        @item markup [Read index.um]
        @item parsed [Parsed AST]
        @item virtual-dom [Virtual DOM]
        @item custom-transforms [Custom Transforms]
        @item html [HTML]
        @item write [Write index.html]

        @link markup -> parsed
        @link parsed --> custom-transforms
        @link custom-transforms --> virtual-dom
        @link virtual-dom -> html
        @link html -> write


  @topic The AST
    @sheet
      Parsing is the process of turning the markup text into objects that can be
      more easily manulipated by computer programs.

      The quantum markup language is designed to be easy to work with once parsed.


      TODO: describe what the ast is (show a small snippet of um and the associated ast)

  @topic Pipeline Transforms
    @sheet
      TODO: Describe what a pipeline transform is: just a function that transforms something to something else (normally ast -> ast)

  @topic Entities
    @sheet
      TODO: Describe what an entity is (or is this well enough covered by the markup section above?)

  @topic Entity Transforms
    @sheet
      TODO: Describe whan an entity transform is (entity -> virtual dom)


@bottomSection
  @paginationButtons
    @previous /: Home
    @next /quick-start/: Quick Start

@footer
